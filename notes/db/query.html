<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html  xmlns="http://www.w3.org/1999/xhtml">  <head>    <meta content="text/html; charset=UTF-8" http-equiv="content-type" />    <title>New</title>    <meta content="Amaya, see http://www.w3.org/Amaya/" name="generator" />  </head>  <body>    <p></p>    <br />    <h1>Access paths</h1>    <p>Access path is the way in which data is retrieved from the table.      Optimizer determines the available paths by looking at the WHERE and FROM      Clauses. It then estimates cost of each plan by using the statistics for      the index/table and then chooses the path with lowest estimated cost. The      decisions of optimizer can be influenced with the hints in the query      statement.  Various access paths are as below:</p>    <ul>    </ul>    <h2></h2>    <table border="2" style="width: 1134px; height: 155px;">      <thead>        <tr>          <th>Access path<br />          </th>          <td><span style="font-weight: bold;">Sub  Type</span><br />          </td>          <th>What<br />          </th>          <th style="margin-left: 78px;">When<br />          </th>          <th style="width: 352px;">Hints<br />          </th>          <th style="margin-left: 58px; width: 372px;">Comments<br />          </th>        </tr>      </thead>      <tbody>        <tr>          <td>Full table scan<br />          </td>          <td><br />          </td>          <td>            <ul>              <li>All rows of the table are read and then filtered based on                WHERE conditions.</li>              <li>DB can read large blocks of sequential data and hence very                efficient for analytical/reporting functions where large dataset                is accessed<br />              </li>            </ul>          </td>          <td>            <ul>              <li>There's no index.</li>              <li>Optimizer determines that large number of rows (actually large                no. of blocks) will be fetched.</li>              <li>Size of the table is very small, can fit in one block.<br />              </li>            </ul>          </td>          <td>            <ul>              <li>FULL (table alias)</li>              <li>CACHE/NOCACHE: whether to keep retrieved rows in buffer cache<br />              </li>            </ul>          </td>          <td><br />          </td>        </tr>        <tr>          <td>Row ID scan<br />          </td>          <td><br />          </td>          <td>            <ul>              <li>RowID gives data file, data block and location of the row in                that block and hence is the fastest way to retrieve a row.</li>              <li>RowID is either specified in the WHERE clause or obtained via                index scan.<br />              </li>            </ul>          </td>          <td>            <ul>              <li>Usually a second step as part of index scan</li>              <li>If index contains all the required columns, it need not fetch                the row.<br />              </li>            </ul>          </td>          <td><br />          </td>          <td>            <ul>              <li>Row IDs are internal Oracle representation. They can change                from version to version, rows can move due to row migration and                during export/import. So, it's generally not a best practice to                access table by row ids.</li>            </ul>          </td>        </tr>        <tr>          <td>Index scan<br />          </td>          <td><br />          </td>          <td>            <ul>              <li>Index contains indexed value as well as the RowID value.</li>              <li>If the statement accesses only indexed columns, it will return                from the index itself, else it will fetch it using RowID<br />              </li>            </ul>          </td>          <td><br />          </td>          <td><br />          </td>          <td>            <ul>              <li>Beware of issues in composite indexes.<br />              </li>            </ul>          </td>        </tr>        <tr>          <td><br />          </td>          <td>Index non-unique<br />          </td>          <td>            <ul>              <li>Assume <span style="font-weight: bold;">non-unique </span>index
                on column C1 and has a total of 6 records with values                (1,2,1,2,1,2). <br />              </li>              <li>All value (1) records could be together in a single block  and                value (2) records could be together in yet another block. When                DB retrieves value (1) rows, it can read single block and is                much more efficient.</li>              <li>This is called clustering factor. <br />              </li>              <li>Low clustering factor: All rows with same index value are                concentrated in close-by blocks.<br />              </li>            </ul>          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td>Index unique-scan<br />          </td>          <td>            <ul>              <li>Unique index guarantees exactly one row so it can be fetched                by RowID.<br />              </li>            </ul>          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td>Index range-scan<br />          </td>          <td>            <ul>              <li>Is used when the index column condition may return more than                records.</li>            </ul>          </td>          <td>            <ul>              <li>Comparison operators (=&lt;, &gt;=, LIKE, BETWEEN)</li>              <li>Is also used when the query doesn't use (=) operator on every                column in the composite index</li>            </ul>          </td>          <td><br />          </td>          <td>            <ul>              <li>Will end up reading multiple blocks because rows for the                indices in the range will be scattered all through.<span style="font-family: monospace;"></span></li>              <li><span style="font-family: monospace;"></span>SELECT * FROM                sales WHERE sale_date between '01-JAN-2003' and '31-DEC-2003'</li>            </ul>          </td>        </tr>        <tr>          <td><br />          </td>          <td>Index skip-scan<br />          </td>          <td>            <ul>              <li>Leading column of the composite index is not specified - i.e.                it's <span style="font-weight: bold;">skipped</span>.</li>              <li>It does multiple passes over the index, one each per the                cardinality of <br />              </li>            </ul>          </td>          <td>            <ul>              <li>When leading column of a composite index is not present in the                WHERE clause but the cardinality of this column is less (i.e.                very less distinct values)</li>              <li>s<br />              </li>            </ul>          </td>          <td>            <ul>              <li>Done automatically by query optimizer if cardinality of the                leading column is less.</li>              <li>Not available prior to 9i.<br />              </li>              <li>INDEX_SS</li>            </ul>          </td>          <td>            <ul>              <li>table employee (eid, sex, address)</li>              <li>composite index (sex, eid)<br />              </li>              <li>Select * from employee where eid = 1000;</li>              <li>It does one pass each for Male employees and Female employees                and looks for eid=1000.<br />              </li>            </ul>          </td>        </tr>        <tr>          <td><br />          </td>          <td>Indes full scan<br />          </td>          <td>            <ul>              <li>Entire index is read, either ascending or descending order</li>              <li>There's no table access post this. All the data is available                as part of the index itself.<br />              </li>            </ul>          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td>Cluster access<br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td>Hash access<br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td>Sample table access<br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>      </tbody>    </table>    <h2><br />    </h2>    <h2><br />    </h2>    <h2>Example indexes</h2>    <p>      <meta charset="utf-8" />    </p>    <pre style="color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px;">CREATE INDEX my_table_i1ON my_table(key_col1, key_col2, key_col3)<br /><meta charset="utf-8" /></pre>    <table border="1" style="font-family: Times; letter-spacing: normal; orphans: 2; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">      <tbody>        <tr bgcolor="cyan">          <td>            <pre>SELECT * FROM my_tableWHERE key_col1 = :aAND   key_col2 = :b</pre>          </td>          <td valign="TOP">Oracle will scan on the first two columns of the            index.</td>        </tr>        <tr bgcolor="cyan">          <td>            <pre>SELECT * FROM my_tableWHERE key_col1 = :aAND   key_col3 = :c</pre>          </td>          <td valign="TOP">Oracle will scan only one the first column of the            index - ie. The leading portion of the index.</td>        </tr>        <tr bgcolor="cyan">          <td>            <pre>SELECT * FROM my_tableWHERE key_col1 = :aAND   key_col2 like '%'AND   key_col3 = :c</pre>          </td>          <td valign="TOP">There are no sneaky workarounds to the previous case.            Oracle will still only scan on the first column.</td>        </tr>        <tr bgcolor="orange">          <td>            <pre>SELECT * FROM my_tableWHERE key_col2 = :bAND   key_col3 = :c</pre>          </td>          <td valign="TOP">As of v9i, the CBO may use an<span class="Apple-converted-space"> </span><a              href="http://www.orafaq.com/tuningguide/index%20skip%20scan.html">Index              Skip Scan</a><span class="Apple-converted-space"> </span>if only            the leading column of the index is not included in the predicates.</td>        </tr>        <tr bgcolor="red">          <td>            <pre>SELECT * FROM my_tableWHERE key_col3 = :c</pre>          </td>          <td valign="TOP">Oracle will not use the index, because the leading            columns are not supplied.</td>        </tr>        <tr bgcolor="cyan">          <td>            <pre>SELECT * FROM my_tableWHERE key_col1 = :aAND   key_col2 &gt;= :bAND   key_col3 = :c</pre>          </td>          <td valign="TOP">Oracle will scan on the first column, and range scan            on the second column, but will not use the index to scan on the            third. The use of a range predicate (&gt;[=], &lt;[=], LIKE,            BETWEEN) or an IN list forces that column to be the last one used in            the scan.</td>        </tr>      </tbody>    </table>    <br class="Apple-interchange-newline" />    <pre style="color: black; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; widows: 2; word-spacing: 0px;"><metacharset="utf-8" /></pre>    <p style="color: rgb(0, 0, 0); font-family: Times; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">Beware      the Range Scan trap when using only the leading part of a concatenated      index. Consider the following:</p>    <ul style="color: rgb(0, 0, 0); font-family: Times; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">      <pre>CREATE UNIQUE INDEX job_i1ON job (company_code, department_code, job_id);SELECT *FROM   jobWHERE  company_code = 'US'AND    job_id = 1134;SELECT STATEMENT    TABLE ACCESS BY ROWID JOB        UNIQUE INDEX RANGE SCAN JOB_I1</pre>    </ul>    <p style="color: rgb(0, 0, 0); font-family: Times; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">We      are providing a very selective WHERE clause that will return probably just      one row, so we expect the SQL to be fast. Explain Plan tells us that it      using the index, so it looks alright. The problem is that we are not      providing the department_code in the WHERE clause, so the index can only      use the leading column provided - ie. company_code. Assuming company_code      is not very selective, we will end up reading most of the index trying to      find our one row.</p>    <p style="color: rgb(0, 0, 0); font-family: Times; font-size: medium; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: normal; orphans: 2; text-align: start; text-indent: 0px; text-transform: none; white-space: normal; widows: 2; word-spacing: 0px; -webkit-text-size-adjust: auto; -webkit-text-stroke-width: 0px; ">This      problem becomes even worse when the range scan is performed on the outer      table of a<span class="Apple-converted-space"> </span><a href="http://www.orafaq.com/tuningguide/join%20methods.html#nested%20loops">nested        loop join</a>, or in a<span class="Apple-converted-space"> </span><a href="http://www.orafaq.com/tuningguide/join%20methods.html#nested%20sub-queries">nested        sub-query</a>. When this happens, we end up reading the entire index      over and over again.</p>    <h1>Joins</h1>    <ul>      <li>Join is stated by multiple tables in the FROM clause and relationship        between these tables is defined in the WHERE clause. <br />      </li>      <li>In case of more than two tables, query optimizer selects first two        tables, joins them and then joins the result set with next table.</li>      <li>Thus a join is always between two tables, one row set is called inner        row set while other is called outer row set.</li>      <li>Row set from each table is accessed using the lowest access path while        the join is performed by one of</li>    </ul>    <br />    <table border="1" style="width: 100%;">      <thead>        <tr>          <td>Join Type<br />          </td>          <td>What<br />          </td>          <td>When<br />          </td>          <td>Hints<br />          </td>          <td>Comments<br />          </td>        </tr>      </thead>      <tbody>        <tr>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>        <tr>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>          <td><br />          </td>        </tr>      </tbody>    </table>    <br />  </body></html>