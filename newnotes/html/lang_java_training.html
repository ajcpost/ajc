<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html  xmlns="http://www.w3.org/1999/xhtml">  <head>    <meta content="text/html; charset=UTF-8" http-equiv="content-type" />    <title>lang</title>    <meta content="Amaya, see http://www.w3.org/Amaya/" name="generator" />  </head>  <body><span style="font-weight: bold;"></span><br />    <ol id="mozToc">      <!--mozToc h1 1 h2 2 h3 3 h4 4 h5 5 h6 6-->      <li><a href="#mozTocId667751">Examples</a>        <ol>          <li><a href="#mozTocId693041">Is there a connection leak?</a></li>          <li><a href="#mozTocId634251">Why extra chairs (&amp; tables)</a></li>          <li><a href="#mozTocId971789">But my dog doesn't bark</a></li>          <li><a href="#mozTocId439179">What could go wrong with this</a></li>          <li><a href="#mozTocId409495">Why does the replace doesn't work</a></li>          <li><a href="#mozTocId720771">What would be the output?</a></li>          <li><a href="#mozTocId29713">Infinite loop?</a></li>        </ol>      </li>      <li><a href="#mozTocId116587">Learnings</a>        <ol>          <li><a href="#mozTocId412660">Design principles, structuring</a></li>          <li><a href="#mozTocId997163">Defensive programming</a></li>          <li><a href="#mozTocId791227">Language nuances</a></li>          <li><a href="#mozTocId287515">Tools</a></li>        </ol>      </li>    </ol>    <br />    <h1><a id="mozTocId667751" class="mozTocH1"></a>Examples <br />    </h1>    <h2><a id="mozTocId693041" class="mozTocH2"></a>Is there a connection leak?</h2>    public class FileCopy {<br />        static void copy(String src, String dest) throws IOException {<br />            InputStream in = null;<br />            OutputStream out = null;<br />            try {<br />                in = new FileInputStream(src);<br />                out = new FileOutputStream(dest);<br />                byte[] buf = new byte[1024];<br />                while ((int n = in.read(buf)) &gt;= 0) {<br />                    out.write(buf, 0, n);<br />                }<br />            }  finally {<br />                if (in != null)  {<br />                    in.close();<br />                }<br />                if (out != null) {<br />                    out.close();<br />                }<br />            }<br />        }<br />    }   <br />    <br />    <ul>      <li>If in.close() throws an exception, out will leak. Use a utility        function (that ignores exception) to close all resources.</li>    </ul>    <h2><a id="mozTocId634251" class="mozTocH2"></a>Why extra chairs/tables</h2>    class Furniture {<br />        private static int count;<br />        public static void increment() {<br />            count++;<br />        }<br />        public static int getCount() {<br />            return count;<br />        }<br />    }<br />    class Chairs extends Furniture {<br />        public Chairs() { <br />            increment();<br />        }<br />    }<br />    class Tables extends Furniture {<br />        public Tables() {<br />            increment();<br />        }<br />    }<br />    <br />    public class Foo {<br />        public static void main(String[] args) {<br />            Chairs[] chairs = { new Chairs(), new Chairs() };<br />            Tables[] tables = { new Tables(), new Tables() };<br />    <br />            System.out.println(chairs.getCount() + " chairs.");<br />            System.out.println(tables.getCount() + " tables.");<br />        }<br />    }<br />    <br />    <span style="font-weight: bold;"></span>    <ul>      <li>count is static, so single copy is shared between        chairs/tables...making it non-static will not work since it will be 1        per every instance of chair/table</li>      <li>real problem is design choice... neither table/char is of type counter        and hence should not inherit from it.<br />      </li>    </ul>    <h2><a id="mozTocId971789" class="mozTocH2"></a><span style="font-weight: bold;"></span>But
      my dog doesn't bark</h2>    public class Foo {<br />        public static void main(String args[]) {<br />            Dog badDog = new Dog();<br />            Dog myGoodDog = new SilentDog();<br />            badDog.bark();<br />            myGoodDog.bark();<br />        }<br />    }<br />    <br />    class Dog {<br />        public static void bark() {<br />            System.out.print("bark");<br />        }<br />    }<br />    <br />    class SilentDog extends Dog {<br />        public static void bark() {<br />    }<br />    <ul>      <li>Static methods are not resolved runtime based on type but rather        attached at compile time.<br />      </li>    </ul>    <span style="font-weight: bold;"></span><br />    <h2><a id="mozTocId439179" class="mozTocH2"></a>What could go wrong with      this</h2>    static private final String LOCK = "LOCK";<br />    void someMethod() {<br />      synchronized(LOCK) {<br />        ...<br />    }<br />    <ul>      <li>Some other class may acquire lock on string "LOCK".<br />      </li>    </ul>    <h2><a id="mozTocId409495" class="mozTocH2"></a>Why does the replace doesn't      work</h2>    <span style="font-weight: bold;"></span>String val = "foo";<br />    val.replace('o', 'f');<br />    if(val.equals("fff")) <span style="font-weight: bold;"></span><br />    <ul>      <li>Single quote?<br />      </li>    </ul>    <br />    <h2><a id="mozTocId720771" class="mozTocH2"></a>What would be the output?</h2>    public class Foo {<br />        public static synchronized void main(String[] a) {<br />            Thread t = new Thread() {<br />                public void run() {<br />                    down();<br />                }<br />            };<br />            t.run();<br />            System.out.print("UP");<br />        }<br />    <br />        static synchronized void down() {<br />            System.out.print("DOWN");<br />        }<br />    }<span style="font-weight: bold;"></span><br />    <ul>      <li>Since thread.start() is not called, there's no separate thread. The        program will always <span style="font-weight: bold;">deterministically</span>        display "DOWNUP"<br />      </li>    </ul>    <br />    <h2><a id="mozTocId29713" class="mozTocH2"></a>Infinite loop?</h2>    public class Loop2 {<br />        public static final int s_begin = Integer.MAX_VALUE - 50;<br />        public static void main(String[] args) {<br />            int count = 0;<br />            for (int i = s_begin; i &lt;= Integer.MAX_VALUE; i++) {<br />                count++;<br />            }<br />            System.out.println(count);<br />        }<br />    }<span style="font-weight: bold;"></span><br />    <ul>      <li>When i reaches max value, it rolls back so starts all over again.<br />      </li>    </ul>    <h1><a id="mozTocId116587" class="mozTocH1"></a>Learnings<br />    </h1>    <h2><a id="mozTocId412660" class="mozTocH2"></a>Design principles,      structuring<span style="font-weight: bold;"></span></h2>    <span style="font-weight: bold;"></span>    <ul>      <li>Clarity, simplicity</li>      <li>Keep it small</li>      <li>Reuse, don't duplicate<br />      </li>      <li>Encapsulation (testability, reuse, independent development)</li>      <li>Minimize change impact, code reuse, extensibility<br />      </li>      <ul>        <li>Single responsibility (e.g. number of if/else)<br />        </li>        <li>Open/Close</li>        <li>Liskov's substitution</li>        <li>Interface segregation<br />        </li>        <li>Dependency inversion<span style="font-weight: bold;"></span></li>      </ul>    </ul>    <h2><a id="mozTocId997163" class="mozTocH2"></a>Defensive programming<span style="font-weight: bold;"></span></h2>    <ul>      <li>Use long vs int</li>      <li>Validate arguments</li>      <li>Return empty objects instead of null</li>      <li>Copy input objects</li>      <li>Use immutable objects </li>    </ul>    <p></p>    <h2><a id="mozTocId791227" class="mozTocH2"></a>Language nuances</h2>    <ul>      <li>Using final<span style="font-family: Arial,'Liberation Sans','DejaVu Sans',sans-serif;"></span></li>      <ul style="margin: 0px 0px 1em 30px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: rgb(255, 255, 255); list-style: disc; color: rgb(0, 0, 0); font-family: Arial, 'Liberation Sans', 'DejaVu Sans', sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-position: initial initial; background-repeat: initial initial;">        <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;"><span            style="font-family: Arial,'Liberation Sans','DejaVu Sans',sans-serif;"></span>Obsess          over:</li>        <ul>          <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Final
            fields - Marking fields as final forces them to be set by end of            construction, making that field reference immutable. This allows            safe publication of fields and can avoid the need for            synchronization on later reads. (Note that for an object reference,            only the field reference is immutable - things that object reference            refers to can still change and that affects the immutability.)</li>          <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Final            static fields - Although I use enums now for many of the cases where            I used to use static final fields.<span style="font-family: Arial,'Liberation Sans','DejaVu Sans',sans-serif;"></span></li>        </ul>        <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Consider          but use judiciously<br />          <span style="font-family: Arial,'Liberation Sans','DejaVu Sans',sans-serif;"></span></li>        <ul>          <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Final            classes - Framework/API design is the only case where I consider it.</li>          <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Final            methods - Basically same as final classes. If you're using template            method patterns like crazy and marking stuff final, you're probably            relying too much on inheritance and not enough on delegation.</li>        </ul>        <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Ignore          unless feeling anal:</li>        <ul>          <li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word; background-position: initial initial; background-repeat: initial initial;">Method            parameters and local variables - I RARELY do this largely because            I'm lazy and I find it clutters the code. I will fully admit that            marking parameters and local variables that I'm not going to modify            is "righter". I wish it was the default. But it isn't and I find the            code more difficult to understand with finals all over. If I'm in            someone else's code, I'm not going to pull them out but if I'm            writing new code I won't put them in. One exception is the case            where you have to mark something final so you can access it from            within an anonymous inner class.</li>        </ul>      </ul>    </ul>    <ul>      <li>        <ul style="margin: 0px 0px 1em 30px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: rgb(255, 255, 255); list-style: disc; color: rgb(0, 0, 0); font-family: Arial, 'Liberation Sans', 'DejaVu Sans', sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-position: initial initial; background-repeat: initial initial;">        </ul>      </li>      <li>Use StringBuilder</li>      <li>Use PreparedStatements</li>      <li>Prefer foreach</li>      <li>Prefer primitives (avoid nulls, extra memory, use of "==" operators)</li>      <li>Declare variables just before use</li>      <li>Don't do String s = new String ("blah")</li>      <li>Make sure to use BigDecimal for float, double</li>      <li>Equals and hashcode</li>      <li>Use Static factory patterns, instead of numerous constructors (name,        no new object etc)</li>      <li>Don't use finalizers</li>      <li>Use enums (singleton, type safety, ordering change has no impact)<br />      </li>    </ul>    <p></p>    <p></p>    <h2><a id="mozTocId287515" class="mozTocH2"></a>Tools<br />    </h2>    <ul>      <li>Junit</li>      <li>FindBug</li>      <li>Eclipse MAT analyzer</li>      <li>Thread dump analyzer</li>    </ul>  </body></html>