<!--?xml version="1.0" encoding="iso-8859-1"?--><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd"><html  xmlns="http://www.w3.org/1999/xhtml">  <head>    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />    <title>New</title>    <meta name="generator" content="Amaya, see http://www.w3.org/Amaya/" />  </head>  <body>    <p></p>    <h1>Basics</h1>    <div class="toc">      <ul>        <li><span style="font-family: Arial,Helvetica,sans-serif"><a href="#L1109">Basics</a></span>          <ul style="font-family: Arial,Helvetica,sans-serif">            <li><a href="#L1111">Instance</a></li>            <li><a href="#L1113">init.ora</a></li>            <li><a href="#L453">SQL</a>              <ul>                <li><a href="#L1121">Syntax</a></li>                <li><a href="#L1151">Select</a></li>                <li><a href="#L360">Rownum, Rowid</a></li>                <li><a href="#L372">Cursors</a></li>                <li><a href="#L3933">Hierarchical data</a></li>              </ul>            </li>          </ul>        </li>        <li style="font-family: Arial,Helvetica,sans-serif"><a href="#L1129">Transactions</a></li>        <li style="font-family: Arial,Helvetica,sans-serif"><a href="#L171"></a><br />        </li>        <li style="font-family: Arial,Helvetica,sans-serif"><a href="#L1471">AWR</a>          <ul>            <li><a href="#L1156">Optimization places</a></li>            <li><a href="#L186"></a><br />            </li>            <li><a href="#L1136">Before comparing</a></li>            <li><a href="#L1138">Terms</a>              <ul>                <li><a href="#L117">Buffer cache</a></li>                <li><a href="#L139">Shared pool cache</a></li>                <li><a href="#L148">Log Buffer</a></li>                <li><a href="#L160">Std block size</a></li>              </ul>            </li>            <li><a href="#L1193">Report</a>              <ul>                <li><a href="#L217">Cache sizes</a></li>                <li><a href="#L226">Load profile</a></li>                <li><a href="#L694">Instance efficiency</a></li>                <li><a href="#L872">Shared pool statistics</a></li>                <li><a href="#L563">Top 5 timed wait</a></li>                <li><a href="#L617">Time model statistics</a></li>                <li><a href="#L639">Foreground wait events</a></li>                <li><a href="#L668">Background wait events</a></li>                <li><a href="#L682">Service related stats</a></li>              </ul>            </li>          </ul>        </li>        <li style="font-family: Arial,Helvetica,sans-serif"><a href="#L1207">References</a></li>        <li style="font-family: Arial,Helvetica,sans-serif"><a href="#L2919"></a><br />        </li>      </ul>    </div>    <h1 id="L1109" style=" font-family: Arial,Helvetica,sans-serif">Basics</h1>    <h2>Instance</h2>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li><strong>Schema</strong> Is a collection of objects (tables, views,        indexes, stored procedures, etc) that is owned by a database user.        <ul>          <li>A database user can own exactly one schema (may have access to            multiple) and hence in a JDBC connection, one need not specify the            schema to use. It's identified automatically based on the user's            credentials.</li>          <li>There's a default user SYS/SYSTEM and associated schemas. The SYS            schema contains data dictionary for the database and the SYS user            has the highest priveleage.</li>        </ul>      </li>      <li><strong>Database</strong> Is a collection of physical files (data        files, redo log files, control files, temp files, etc). These are        identified by a System identifier called as SID.</li>      <li><strong>Instance</strong> Is a set of Oracle processes (&amp; their        shared memory area) that operate on a database. In most cases instance        == sid, but may differ in some cases, e.g. RAC where multiple instnaces        operate on the same database.        <ul>          <li>Running more than one instance on a given physical server is _NOT_            a recommended practice. One instance can hit the system resources            hard and affect other instance. </li>        </ul>      </li>      <li><strong>Tablespace</strong> Is a logical grouping for schema objects.        All schemas must belong to one of the tablespaces.</li>      <li><strong>Connection</strong> A connection created by client code to an        oracle instance process above. (1 instance --&gt; many connections)</li>      <li><strong>Session</strong> A session created by client code over an        existing connection. (1 connection --&gt; many sessions)</li>    </ul>    <p style="font-family: Arial,Helvetica,sans-serif"><img width="491" height="206"        alt="instance detials"        src="IMG/instance.png" /></p>    <p style="font-family: Arial,Helvetica,sans-serif"></p>    <h2 id="L453" style=" font-family: Arial,Helvetica,sans-serif">SQL</h2>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Insert into &lt;table&gt; values (comma separated values)</li>      <li>Insert into &lt;table&gt; (comma separated column names) values (comma        separated values)</li>      <li>Update &lt;table&gt; SET &lt;column&gt;=value, &lt;column&gt;=value        WHERE &lt;column&gt; = value (Where clause is mandatory)</li>      <li>Delete from &lt;table&gt; WHERE &lt;column&gt; = value (Where clause        is mandatory)</li>      <li>Select from ....</li>      <li>Not case sensitive</li>      <li>DML (Data manipulation language)        <ul>          <li>Select, update, delete, insert into</li>        </ul>      </li>      <li>DDL (Data definition language)        <ul>          <li>create database, alter database</li>          <li>create table, alter table, drop table</li>          <li>create index, drop index</li>        </ul>      </li>      <li>Date/time handling: </li>    </ul>    <h3 id="L1151" style=" font-family: Arial,Helvetica,sans-serif">Select</h3>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Most likely optimizer will handle the correct ordering for Join but        it's better to look at the execution plans and validate.</li>      <li>JOIN clause should occur before HAVING clause?</li>      <li>If no column is selected and if it's a JOIN query, it will display        columns from all the tables.</li>      <li>WHERE clause doesn't understand aggregate functions (e.g. select        employee, sum (bonus) from emp group by employee where sum(bouns) &gt;        1000). In these cases, need to use HAVING clause.</li>      <li>select * from transactions where login in ('john', 'peter', 'aj')</li>      <li>select * from transactions where login like '%john%'</li>      <li>select * from transactions where login between 'aj' and 'john'        (whether 'aj' and 'john' is inclusive depends on the DB!)</li>      <li>select distinct login, transaction_city from transactions (distinct on        multiple columns)</li>      <li>like (using %, _, [charlist], [^charlist], escape)        <ul>          <li>like 'j%' : Everything starting with j</li>          <li>lile 'a%j' : Everything starting with a and ending with j</li>          <li>like 'tp_dd' : Matching exactly 5 chars beginning with tp and            ending with dd</li>          <li>like '[bj]%' : Matching starting with b or j</li>          <li>like '[^bj]%': Matching not starting with b or j</li>          <li>like '!%aj' escape '!' : Maching exactly "%aj". Escape char            specified explicitely.</li>        </ul>      </li>      <li>Processing steps        <ul>          <li>From/Where clause </li>          <li>Rownum is assigned </li>          <li>Select is applied </li>          <li>Group by is applied </li>          <li>Having is applied </li>          <li>Order by is applied</li>        </ul>      </li>    </ul>    <h3 id="L360" style=" font-family: Arial,Helvetica,sans-serif">Rownum, Rowid</h3>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Rownum is a pseudo column assigned after retrieving the result set.        It's applied just after where clause so will not get applied to order by        or other clauses unless inner query is mechanism is used.</li>      <li>Rowid identifies a physical location of a record and hence is always        present. It's unique within a table but <strong>may</strong><strong>have
          duplicate</strong> values across tables. If the record is physically        moved (e.g. index organized or partitioned tables), rowid will change.</li>    </ul>    <h3 id="L372" style=" font-family: Arial,Helvetica,sans-serif">Cursors</h3>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Every query execution will have a cursor associated with it, either        explicitly requested by the client code or implicitly created by Oracle.        This can be used to fetch result values.</li>      <li>It's a good practice to close the cursor, not just the connection,        from Java programs. A bad JDBC driver may not close the cursor during        connection close and will lead to "max open cursors" error.        <p>Connection conn = dataSource.getConnection();</p>        <p style="margin-left:2em;">try{</p>        <p style="margin-left:4em">PreparedStatement stmt =          conn.prepareStatement();</p>        <p style="margin-left:4em">//initialize the statement</p>        <p style="margin-left:4em">stmt.execute();</p>        <p style="margin-left:4em">ResultSet rs = stmt.getResultSet();</p>        <p style="margin-left:4em">//get data</p>        <p style="margin-left:2em;">}finally{</p>        <p style="margin-left:4em">stmt.close();</p>        <p style="margin-left:4em">rs.close();</p>        <p style="margin-left:4em">conn.close();</p>        <p style="margin-left:2em;">}</p>      </li>    </ul>    <h4 id="L3933" style="font-family: Arial,Helvetica,sans-serif">Hierarchical      data</h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>SQL is about SETs and not meant for hierarchical data (e.g.        company-&gt;dept-&gt;sub-dept-&gt; or ceo-&gt;executive mgmt-&gt;senior        mgmt-&gt;mgmt-&gt;employees).</li>      <li>There are ways in which it can be modelled (see Nested Sets, Common        table expressions) and many modern DBs support special syntax for        recurssive traversal.</li>    </ul>    <hr />    <h1 id="L1111" style="  font-family: Arial,Helvetica,sans-serif;">Best      Practices<br />    </h1>    <h2 id="L1111" style=" font-family: Arial,Helvetica,sans-serif;">Storing      binary data <br />    </h2>    <p></p>    Pros<br />    <ul>      <li>You can commit the update of the document itself in the same        transaction as the information (name, date etc) you want to store about        the document. This means you don't have to worry about writing your own        two-phase commit (although ISTR that SQL Server 2008 has a solution for        this).</li>      <li>You can back up the whole lot (documents and metadata) at once,        without worrying about having to synchronise the database with the file        system</li>      <li>You can deliver documents very simply over .NET web services, since        they come straight out into DataTables, and are serialised effortlessly        just by putting the DataTables into a DataSet and passing it.</li>      <li>You can apply database security to the objects, as to the rest of your        data, and not have to worry about network file permissions.</li>    </ul>    <p style="margin: 0px 0px 1em; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: rgb(255, 255, 255); clear: both; word-wrap: break-word; color: rgb(0, 0, 0); font-family: Arial, 'Liberation Sans', 'DejaVu Sans', sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-position: initial initial; background-repeat: initial initial;">Cons</p>    <ul style="margin: 0px 0px 1em 30px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: rgb(255, 255, 255); list-style: disc; color: rgb(0, 0, 0); font-family: Arial, 'Liberation Sans', 'DejaVu Sans', sans-serif; font-style: normal; font-variant: normal; font-weight: normal; letter-spacing: normal; line-height: 18px; orphans: auto; text-align: left; text-indent: 0px; text-transform: none; white-space: normal; widows: auto; word-spacing: 0px; -webkit-text-stroke-width: 0px; background-position: initial initial; background-repeat: initial initial;">      <li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word; background-position: initial initial; background-repeat: initial initial;">Backups        can get very large</li>      <li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word; background-position: initial initial; background-repeat: initial initial;">The
        size of the binary object in the database can be quite a bit larger than        the file it originally came from, and therefore in a client-server        environment, it can increase the time taken to open them across the        network.</li>      <li style="margin: 0px; padding: 0px; border: 0px none; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word;">Depending
        on the application, you might need to consider the load on the database        server if it has to serve up a lot of large documents.</li>      <li style="margin: 0px; padding: 0px; border: 0px; font-size: 14px; vertical-align: baseline; background-color: transparent; word-wrap: break-word; background-position: initial initial; background-repeat: initial initial;">Binary        files lose their 'fileness' <br />      </li>    </ul>    <br class="Apple-interchange-newline" />    <p></p>    <h3 id="L1111" style="font-family: Arial,Helvetica,sans-serif"></h3>    <h2 id="L1129" style="font-family: Arial,Helvetica,sans-serif;"></h2>    <hr />    <h1 id="L1471" style=" font-family: Arial,Helvetica,sans-serif;">Oracle</h1>    <h2 id="L1113" style=" font-family: Arial,Helvetica,sans-serif">init.ora</h2>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Is the overall configuration for a given Oracle instance and has a        huge impact on the overall performance.</li>      <li>Optimizer settings        <ul>          <li>optimizer_mode            <ul>              <li>= first_rows: Will favour index access over full table scan to                return rows as quickly as possibile. In some cases, it may                result in more resource consumption (e.g. indexed access has to                first read indexes and may in some cases incur additional io                overhead).Usually used for <strong>online</strong> systems</li>              <li>= all_rows: Will favour full table scan when server resources                will be minimized. Usually used for <strong>batch</strong>                systems. <span style="font-weight: bold;"></span><span style="font-weight: bold;"></span></li>              <li>Explain plan<br />                on sql prompt<br />                explain plan for "sql statement";<br />                set linesize 132<br />                select * from table (dbms_xplan.display); </li>            </ul>          </li>          <ul>          </ul>        </ul>      </li>    </ul>    <h2 id="L1471" style="font-family: Arial,Helvetica,sans-serif;"></h2>    <h2 id="L1471" style="  font-family: Arial,Helvetica,sans-serif">AWR</h2>    <h4 id="L1156" style=" font-family: Arial,Helvetica,sans-serif">Optimization      places</h4>    <h3 id="L186" style="font-family: Arial,Helvetica,sans-serif"></h3>    <p style="font-family: Arial,Helvetica,sans-serif"><a href="IMG/sql_tuning_hierarchy.gif"><img          width="509"          height="344"          alt="tuning possibilities"          src="IMG/sql_tuning_hierarchy.gif" /></a></p>    <p style="font-family: Arial,Helvetica,sans-serif"></p>    <h4>Report summary</h4>    <h3></h3>    <h4 id="L1136" style="font-family: Arial,Helvetica,sans-serif">Before      comparing</h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Make sure ora.init params are same</li>      <li>begin/end snap timings are similar</li>      <li>load characteristics are similar (e.g. no. of requests, pass/fail        ratio, no. of concurrent users)</li>    </ul>    <h4 id="L139" style="font-family: Arial,Helvetica,sans-serif">Cache sizes<strong></strong></h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Compare cache sizes to see differences between cache effectiveness.</li>      <li>If Shared pool size is increasing, it may indicate usage of SQLs        without bind variables.</li>      <li><strong>Buffer cache</strong> Is a cache of blocks read from disk.        <ul>          <li>Is segmented into multiple sets to redue contention on            multipprocessor systems. </li>          <li>Has multiple pools            <ul>              <li>Keep pool: Small objects that should always be cached, e.g.                look up tables </li>              <li>Recycle pool: Larger objects which are arranged based on                MRU--&gt;LRU </li>              <li>Default pool<strong></strong><strong></strong></li>            </ul>          </li>        </ul>      </li>      <li><strong>Shared pool cache</strong> Stores metadata like query plans,        parsed SQL statements, open cursors.        <ul>          <li>Should remain of same size, else indicates that bind variables are            not being used<strong></strong></li>        </ul>      </li>      <li><strong>Log Buffer</strong> Caches redo logs that are being written        for each transaciton.        <ul>          <li>Must be flushed to disk along with transaction commit. </li>          <li>Redo disks must be able to support rates equal to sum of rates            across all data disks. The buffer is written synchronously.</li>          <li>A small value will result in high "redo log space request event"            while high value will result in high "log file sync" events.</li>        </ul>      </li>      <li><strong>Std block size</strong> Blocke size used by Oracle to store        disk blocks.        <ul>          <li>If a small value is used, it may have large space overhead since            each block needs to maintain metadata. It's efficient in cases where            row sizes are small and have lots of random access. This is because            there's less contention.</li>          <li>If a large value is used, it may waste space when doing random            access (e.g. 50 byte record size in an 8K block). It's also not good            for index blocks since it increases block level contention. It's            good for sequential access or large rows.</li>        </ul>      </li>    </ul>    <h4 id="L226" style="font-family: Arial,Helvetica,sans-serif">Load profile</h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Gives an idea of the work profile on the database.</li>      <li><strong>Redo size</strong> indicates the overall work. Note that it's        not just Update/delete but Select <strong>may</strong> also cause redo        to be generated if it has to read blocks in cache (i.e. not available in        buffer) and in doing so it may touch(dirties) the block headers. These        must be written back to the disk.</li>      <li><strong>Logical reads</strong> Is equal to consistent get + DB block        gets        <ul>          <li>DB block gets is more of internal processing by Oracle.</li>          <li>Consistent get is reading of a block from buffer cache. A check            will be made if data needs to be reconstructed from rollback logs to            get a consistent reads isolation level. </li>          <li>Aim should be to minimize consistent gets even though these are            from cach. These represent the work DB is doing and SQLs can be            tuned to read less. Also, Oracle must acquire a latch before each            consistent get resulting in contention.</li>        </ul>      </li>      <li><strong>Block changes</strong> Is the total no. of changes to data        blocks due to DMLs. Note that a single insert may cause changes to more        than one block if indexes are included.</li>      <li><strong>User calls</strong> Is the total number of calls client makes        to the instance. Oracle allocates internal structures (call stat        objects) to keep track of relevant user data structures for every login,        parse, execute statement. This should be minimized.</li>      <li><strong>Parses</strong> Every SQL statement must be parsed before        execution. The steps involved are:        <ol>          <li>Syntax check as per the grammer.</li>          <li>Semantic check: do the tables actually exist, does user have            rights, column name ambiguity (e.g. select c1 from t1, t2 and both            t1/t2 have column c1)</li>          <li>Check if shared pool already has the SQL            <ul>              <li>For SQL to be identical, all characters must match, all                objects must match.</li>              <li>e.g. "select NAME from customer" is different from "select                name from customer"</li>              <li>e.g. "select NAME from customer" is different if accessed by                "xyz" and by "pqr"</li>              <li>If bind variables are not used, it will result in many unique                SQLs                <ul>                  <li>"select name from customer where id = 1234" is different                    than "select name from customer where id = 9999"</li>                  <li>Use "select name from customer where id = :cust_id"</li>                </ul>              </li>            </ul>          </li>          <li><strong>Below statements require a latch on shared pool</strong></li>          <li>Allocate memory in shared pool (if no memory free in shared pool,            it must age out previous entries)</li>          <li>Get values of bind variables and see if values fit in the selected            columns (no. of columns specified vs no. of values specified)</li>          <li>Optimize query execution (consumes a lot of CPU)</li>          <li>Build the parse tree and execution plan in a format that SQL can            use (row source generation)</li>          <li>Store in shared pool</li>        </ol>      </li>      <li><strong>Soft parse</strong> Finds parsed SQL at step 3 and doesn't        have to execute rest of the statements.</li>      <li><strong>Hard parse</strong> all the steps above.</li>      <li>If no of parses are high, it typically happens in stateless client        where client code does a prepare every time instead of creating one time        and reusing.</li>      <li><strong>Sorts</strong> Oracle will perform sorting on row data when        using "order by" and "group by" and when an index is created.        <ul>          <li>Sorting can be during rows retrieval or after rows retrieval. This            a is influenced by a number of parameters including some optimizer            settings.</li>          <li>Sorting can be very costly on large data sets. If the results do            not fit in-memory, temp tables must be used.</li>        </ul>      </li>    </ul>    <h4 id="L694" style="font-family: Arial,Helvetica,sans-serif">Instance      efficiency</h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Aim is to reach close to 100% for each of the metric. However, note        that these are to be used as a supplement. Ratios hide scale -- a 100%        soft parse ratio appears good but may be a terrible thing if total no.        of soft parses per sec is way too high. Always look at this data along        with per seond data in Load Profile section.</li>      <li><strong>Buffer nowait %</strong> How many times the data buffers were        accessed without wait (i.e. no contention). This includes all buffers so        if this ration is low, one can look in buffer stats to investigate        further.</li>      <li><strong>Buffer hit ratio %</strong> How many times the required block        was found in memory instead of having to do physical IO.</li>      <li><strong>Library hit %</strong> How many times SQL statements and        PL/SQL packages were found in shared pool.</li>      <li><strong>Execute to Parse %</strong> Ratio of no. of parses vs no. of        executes. Is equal to round(100*(1-parse/exeute),2)        <ul>          <li>If parses = execute this ratio will be close to zero</li>          <li>if parses &gt; execute (app parses the stmt but never executes            it), this ratio will be negative. </li>          <li>If parses &lt; execute, this ratio will be positive. </li>          <li>If this ratio is low, it's indicative that client code is not            reusing a preparted statement but rather creating it every time.            This would lead to parse during every execute and bring down the            ratio.</li>        </ul>      </li>      <li><strong>Parse CPU to parse Elapsed %</strong> Ratio of CPU time spent        actually parsing SQL statements vs total elapsed time during parse.</li>      <li><strong>Redo no wait %</strong> How many times redo log buffers were        acquired without having to wait. Gives an indication whether redo log        buffers are of sufficient size.</li>      <li><strong>In-memory sort %</strong> How many times sorts are performed        in memory instead of using temp table</li>      <li><strong>Soft parse %</strong> No of times SQLs were soft parsed.</li>      <li><strong>Latch hit nowait %</strong> How often latches were acquired        without having to wait.</li>      <li><strong>% Non parse CPU</strong> How much CPU resources were spent on        actual SQL execution.</li>    </ul>    <h4 id="L872" style="font-family: Arial,Helvetica,sans-serif">Shared pool      statistics</h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li><strong>Memory usage </strong><strong>%</strong><strong></strong> If        a lot of shared pool memory (e.g. 90%) is consumed then system may        experience overheads aging out old data structures.</li>      <li><strong>% SQL with executions &gt;1</strong> How many SQLs were        executed more than once. Indicates whether SQLs are being reused.</li>    </ul>    <p></p>    <h3 style="font-family: Arial,Helvetica,sans-serif">Report Details</h3>    <h4>Wait event statistics</h4>    <ul style="font-family: Arial,Helvetica,sans-serif">      <li>Top areas where DB is spending time waiting.        <ul>          <li>DB file type waits - physical io</li>          <li>Buffer type waits - logical io</li>          <li>LOG type waits - redo related</li>          <li>Px - Parallel query</li>          <li>GC - Global cache (RAC) related</li>        </ul>      </li>      <li>Two main IO events in Oracle        <ul>          <li><strong>db file sequential read</strong> Is a wait event by DB for            OS to return a single disk block. This typically happens when Users            do a index query and the block is not available in Cache.</li>          <li><strong>db file scattered read</strong> Is a wait event by DB for            OS to return multiple disk blocks. This typically happens when Users            do a full table scan.</li>        </ul>      </li>      <li><strong>CPU time</strong> Is the time spent on CPU doing actual work.        <ul>          <li>It's not a wait event and hence the wait column will be empty.</li>          <li>If the number is 37,677seconds.... Assuming 7 hr load window and 2            CPUs, total seconds = 50400 seconds (2*7*60*60). So % time spent on            CPU is 74% and system is clearly CPU bound.</li>          <li>Note that this would be same as DB CPU in time model statistics            below. However, the one in "Top 5" timed event is shown only at the            end of query execution while the one in "Time model statistics" is            incremented at short intervals so depending on when the report was            taken, these values may differ.</li>        </ul>      </li>      <li><strong>Log file sync</strong> indicates that the process is waiting        for LGWR to finish flushing the redo log buffer to disk. This occurs        when a user commits a transaction.        <ul>          <li>If this event has high value but if the avg wait time is low, it            indicates that app is doing too many commits rather than batching.</li>          <li>If this event has high value and if the avg wait time is high, it          </li>          <li>Common solutions to eliminate these wait events is to use faster            redo disks and increasing the log-buffer size.</li>        </ul>      </li>      <li><strong>Log file parallel write</strong> indicates the time LGWR spent        waiting to write groups of redo logs.        <ul>          <li>When client commits a transaction, it waits on Log file sync for            LGWR to complete the write.</li>          <li>LGWR in turn will wait on Log file parallel event. However, there            may not be 1:1 correspondence, since LGWR will group together redo            log writing for many sessions. 50 people issue commit and they wait            1 unit of time, and lgwr takes 1 unit of time to do it's write, you            will have 50 units of log file sync wait time and 1 unit of lgwr IO            time.</li>        </ul>      </li>    </ul>    <h4 id="L617" style="font-family: Arial,Helvetica,sans-serif">Time model      statistics</h4>    <ul>      <li style="font-family: Arial,Helvetica,sans-serif">Shows where system is        spending time.        <ul>          <li>Most important metrics are DB time and DB CPU.</li>          <li>Time is shown as absolute value and also % of total DB time.</li>          <li style="font-family: Arial,Helvetica,sans-serif">SQL processing            time should be high, parsing and other stuff low</li>        </ul>      </li>      <li style="font-family: Arial,Helvetica,sans-serif"><strong>DB time</strong>        Total time in database calls by foreground sessions. Includes CPU time,        IO time, non-idle wait time.        <ul>          <li style="font-family: Arial,Helvetica,sans-serif">If User is not            doing any activity, it will _not_ add up to DB time (note it doesn't            include time from background processes)</li>          <li>DB time increases as system load increases and also as performance            degrades            <ul>              <li style="font-family: Arial,Helvetica,sans-serif">If there are                more users, there will be more database calls and will effect DB                time.</li>              <li style="font-family: Arial,Helvetica,sans-serif">If there are                larger transactions, there will be more SQLs per call and will                effect DB time.</li>              <li>If application performance degrades, there will be more                elapsed time per SQL and will effect DB time.</li>              <li style="font-family: Arial,Helvetica,sans-serif">If IO is                slower, IO wait time will increase and will effect DB time.</li>              <li style="font-family: Arial,Helvetica,sans-serif">If server is                CPU bound, foreground processes will wait longer in run-queue,                there will be increases in wait event times and will effect DB                time.</li>            </ul>          </li>        </ul>      </li>    </ul>    <h4 id="L639" style="font-family: Arial,Helvetica,sans-serif">Foreground      wait events</h4>    <p style="font-family: Arial,Helvetica,sans-serif">Foreground = user process</p>    <p style="font-family: Arial,Helvetica,sans-serif">Usually most important</p>    <p style="font-family: Arial,Helvetica,sans-serif">Usual source for top 5      wait events</p>    <p style="font-family: Arial,Helvetica,sans-serif">Classes &amp; events.      Classes are rolled up sums for waits.</p>    <h4 id="L668" style="font-family: Arial,Helvetica,sans-serif">Background      wait events</h4>    <p style="font-family: Arial,Helvetica,sans-serif">For background processes      - PMON, SMON, LMON, DBWR etc</p>    <h4 id="L682" style="font-family: Arial,Helvetica,sans-serif">Service      related stats</h4>    <p style="font-family: Arial,Helvetica,sans-serif">Grouping of processes</p>    <p></p>    <h3>Examples</h3>    <h4>Buffer cache ratio 99%, yet db sequential reads are high</h4>    <ul>      <li>Ratios hide scale... If the volumes are very high, the 1% physical        reads re may be It will take 100 buffer gets for every physical read.        So, if there are small tables which are cached and are frequently        accessed, these will make the ratio high.</li>      <li>If db sequential reads are high, look at SQLs by reads</li>      <li>If db sequential reads are high and buffer cache ratio is high too,        look at SQLs by gets.</li>    </ul>    <p><strong>Time model statistics</strong></p>    <ul>      <li>SQL execute is 90%, DB CPU is 20%. There may be lots of waits.</li>      <li>In general, SQL processing should be more, parsing and others should        be small</li>    </ul>    <p><strong>log file sync</strong></p>    <ul>      <li>If log file sync events are high, typically log file parallel write        events would be high too.</li>      <li>If the avg wait for these metrics is less (few ms), then the only        issue is no. of transactions doing commits. </li>    </ul>    <h2 id="L1207" style="font-family: Arial,Helvetica,sans-serif">References</h2>    <ul>      <li style="font-family: Arial,Helvetica,sans-serif">http://www.w3schools.com/sql/sql_syntax.asp</li>      <li style="font-family: Arial,Helvetica,sans-serif">http://www.programmerinterview.com/index.php/database-sql/find-maximum-value-without-using-aggregate/
        (Look at compare problem)</li>      <li><br />      </li>    </ul>  </body></html>